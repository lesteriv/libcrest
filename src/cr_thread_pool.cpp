/**********************************************************************************************/
/* cr_thread_pool.cpp				                                               			  */
/*                                                                       					  */
/* Igor Nikitin, 2013																		  */
/* MIT license			                                                  					  */
/**********************************************************************************************/

// LIBCREST
#include "cr_thread_pool.h"


//////////////////////////////////////////////////////////////////////////
// helper class
//////////////////////////////////////////////////////////////////////////


/**********************************************************************************************/
class cr_worker
{
	public://////////////////////////////////////////////////////////////////////////
	  
							void operator()()
							{
								function<void()> task;
								while( 1 )
								{
									{
										unique_lock<mutex> lock( pool_.queue_mutex_ );

										while( !pool_.stop_ && pool_.tasks_.empty() )
											pool_.condition_.wait( lock );

										if( pool_.stop_ )
											return;

										task = pool_.tasks_.front();
										pool_.tasks_.pop_front();
									}

									task();
								}										
							}

	public://////////////////////////////////////////////////////////////////////////

		cr_thread_pool&		pool_;
};


//////////////////////////////////////////////////////////////////////////
// construction
//////////////////////////////////////////////////////////////////////////


/**********************************************************************************************/
cr_thread_pool::cr_thread_pool( size_t count )
{
	stop_ = false;

	for( size_t i = 0 ; i < count ; ++i )
		workers_.push_back( thread( cr_worker( { *this } ) ) );
}

/**********************************************************************************************/
cr_thread_pool::~cr_thread_pool( void )
{
	stop_ = true;
	condition_.notify_all();

	for( auto& it : workers_ )
		it.join();
}

